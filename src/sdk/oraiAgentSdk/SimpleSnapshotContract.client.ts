/**
 * This file was automatically generated by @oraichain/ts-codegen@0.35.9.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @oraichain/ts-codegen generate command to regenerate this file.
 */

import {
  CosmWasmClient,
  SigningCosmWasmClient,
  ExecuteResult,
} from '@cosmjs/cosmwasm-stargate';
import { Coin, StdFee } from '@cosmjs/amino';
import {
  Addr,
  InstantiateMsg,
  ExecuteMsg,
  Uint128,
  Binary,
  Staker,
  QueryMsg,
  ArrayOfUint64,
  ArrayOfStaker,
  ArrayOfTokensMetadataResponse,
  TokensMetadataResponse,
} from './SimpleSnapshotContract.types';
export interface SimpleSnapshotContractReadOnlyInterface {
  contractAddress: string;
  stakers: ({
    slot,
    token,
  }: {
    slot: number;
    token: string;
  }) => Promise<ArrayOfStaker>;
  numberSlot: ({ token }: { token: string }) => Promise<ArrayOfUint64>;
  tokenMetadata: ({ token }: { token: string }) => Promise<Binary>;
  tokensMetadata: () => Promise<ArrayOfTokensMetadataResponse>;
}
export class SimpleSnapshotContractQueryClient
  implements SimpleSnapshotContractReadOnlyInterface
{
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.stakers = this.stakers.bind(this);
    this.numberSlot = this.numberSlot.bind(this);
    this.tokenMetadata = this.tokenMetadata.bind(this);
    this.tokensMetadata = this.tokensMetadata.bind(this);
  }

  stakers = async ({
    slot,
    token,
  }: {
    slot: number;
    token: string;
  }): Promise<ArrayOfStaker> => {
    return this.client.queryContractSmart(this.contractAddress, {
      stakers: {
        slot,
        token,
      },
    });
  };
  numberSlot = async ({ token }: { token: string }): Promise<ArrayOfUint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      number_slot: {
        token,
      },
    });
  };
  tokenMetadata = async ({ token }: { token: string }): Promise<Binary> => {
    return this.client.queryContractSmart(this.contractAddress, {
      token_metadata: {
        token,
      },
    });
  };
  tokensMetadata = async (): Promise<ArrayOfTokensMetadataResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tokens_metadata: {},
    });
  };
}
export interface SimpleSnapshotContractInterface
  extends SimpleSnapshotContractReadOnlyInterface {
  contractAddress: string;
  sender: string;
  whitelist: (
    {
      slot,
      stakers,
      token,
    }: {
      slot: number;
      stakers: Staker[];
      token: string;
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  storeNumberSlot: (
    {
      numSlot,
      token,
    }: {
      numSlot: number;
      token: string;
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  storeTokenMetadata: (
    {
      metadata,
      token,
    }: {
      metadata: Binary;
      token: string;
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  removeTokenMetadata: (
    {
      token,
    }: {
      token: string;
    },
    _fee?: number | StdFee | 'auto',
    _memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
}
export class SimpleSnapshotContractClient
  extends SimpleSnapshotContractQueryClient
  implements SimpleSnapshotContractInterface
{
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(
    client: SigningCosmWasmClient,
    sender: string,
    contractAddress: string
  ) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.whitelist = this.whitelist.bind(this);
    this.storeNumberSlot = this.storeNumberSlot.bind(this);
    this.storeTokenMetadata = this.storeTokenMetadata.bind(this);
    this.removeTokenMetadata = this.removeTokenMetadata.bind(this);
  }

  whitelist = async (
    {
      slot,
      stakers,
      token,
    }: {
      slot: number;
      stakers: Staker[];
      token: string;
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        whitelist: {
          slot,
          stakers,
          token,
        },
      },
      _fee,
      _memo,
      _funds
    );
  };
  storeNumberSlot = async (
    {
      numSlot,
      token,
    }: {
      numSlot: number;
      token: string;
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        store_number_slot: {
          num_slot: numSlot,
          token,
        },
      },
      _fee,
      _memo,
      _funds
    );
  };
  storeTokenMetadata = async (
    {
      metadata,
      token,
    }: {
      metadata: Binary;
      token: string;
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        store_token_metadata: {
          metadata,
          token,
        },
      },
      _fee,
      _memo,
      _funds
    );
  };
  removeTokenMetadata = async (
    {
      token,
    }: {
      token: string;
    },
    _fee: number | StdFee | 'auto' = 'auto',
    _memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_token_metadata: {
          token,
        },
      },
      _fee,
      _memo,
      _funds
    );
  };
}
